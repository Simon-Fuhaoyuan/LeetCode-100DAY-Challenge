#include <iostream>
#include <vector>
#include <stack>
using namespace std;

/**
 * This solution is generated by myself, which is slower.
 * First, we need to find a 'peak', which means this bar's height is bigger than its neighbours', we call it 'left'.
 * Then, each time we get a new peak, let's say, 'index', we should compare 'index' with 'left', there are two scenarioes.
 * * First scenario is 'index' is higher than or equals to 'left', then we can make sure that each bar between 'left'
 * * * and 'index' can hold 'left'-'height(bar)' water. And the 'index' now is 'left'.
 * * Second scenario is 'index' is lower than 'left', which means there may be higher peak later, and the 'index' we find
 * * * now will be filled with water too. This time, we need to first calculate the water between them and change height
 * * * of each bar between them to 'index'.
 * Actually, this solution is a little bit complex and difficult to realize. For a easier solution, Solution2 is better fit.
 */

class Solution {
public:
    int trap(vector<int>& height) {
        int size = height.size();
        int ans = 0;
        int left = 0, right = 0;
        while (left < size - 1 && height[left] <= height[left + 1])
            left++;
        int index = left + 2;
        while (index < size) {
            while ((index < size - 1 && height[index] <= height[index + 1]) ||
                (index < size && height[index] < height[index - 1]))
                index++;
            if (index >= size)
                break;
            if (height[index] >= height[left]) {
                for (int i = left + 1; i <= index; ++i)
                    if (height[i] < height[left])
                        ans += (height[left] - height[i]);
                left = index;
                index = left + 2;
            }
            else {
                for (int i = left + 1; i < index; ++i)
                    if (height[i] < height[index]) {
                        ans += (height[index] - height[i]);
                        height[i] = height[index];
                    }
                index++;
            }
        }

        return ans;
    }
};

/**
 * This solution is not created by me, but from leetCode 0ms solution.
 * This thinking is easy and quick. For each bar, we just consider the highest bar at the left side and right side of it.
 * So we just record each leftMax and rightMax into two vectors, note that we need to consider the smaller one.
 * Finally, for each bar, if it is lower than min(leftMax, rightMax), it can be filled with some water.
 */

class Solution2 {
public:
    int trap(vector<int>& height) {
        int size = height.size();
        vector<int> leftBar(size, 0);
        vector<int> rightBar(size, 0);
        int leftMax = 0, rightMax = 0;

        for (int i = 0; i < size; ++i) {
            leftBar[i] = leftMax;
            leftMax = max(leftMax, height[i]);
            rightBar[size - i - 1] = rightMax;
            rightMax = max(rightMax, height[size - i - 1]);
        }

        int ans = 0;
        int tmp = 0;
        for (int i = 0; i < size; ++i) {
            tmp = min(leftBar[i], rightBar[i]) - height[i];
            ans += tmp > 0 ? tmp : 0;
        }

        return ans;
    }
};

int main() {
    Solution s;
    vector<int> height({0,1,0,2,1,0,1,3,2,1,2,1});
    cout << s.trap(height) << endl;

    return 0;
}